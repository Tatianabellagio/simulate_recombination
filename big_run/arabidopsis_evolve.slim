// Author: Tati
// simulate evolution of qtl under different environments defined by an optima file 

////////////////////////////////////////////////////////////////////////////////
// Setup

initialize() {
	// the optima file is a vector indicating the optima for each of the environments 
	//optima = readFile('optima.txt');
	//if (!exists("X"))
	//if (!exists("optima"))defineConstant('optima', 'optima0');
	optimas = readFile('optima_files/optima_slim.txt');
	if (!exists("optima"))defineConstant('optima', 0);
	defineConstant('optima_value', asFloat(optimas[optima]));
   defineConstant('ref_fasta', "chr5.fasta");
   defineConstant('main_vcf', "chr5_grenenet_ann4.vcf");
   defineConstant('initial_pop', 28800); // this is based on the number of individuals in the vcf file  28800
   if (!exists("replicates"))defineConstant('replicates', 12);
   if (!exists("gen_to_run"))defineConstant('gen_to_run', 3);
	//defineConstant('gen_to_finish', gen_to_run + 1);

	// number of population based on the map file
	//replicates = length(optima_value);
	

// end options	////////////////////////////////////////////////////////////////////////////////

   // now im gonna simulate the mutations coming from standing variation. 
   print("Starting simulation now with optima: " + optima_value + ", number of generations: " + gen_to_run + " and" + replicates + " replicates in chromosome " + ref_fasta);

   initializeSLiMModelType("nonWF");
   initializeSLiMOptions(nucleotideBased=T);
	length = initializeAncestralNucleotides(ref_fasta);   
	initializeMutationTypeNuc("m2", 0, "n", 0, 0.0);   // qtl1 196 # 19625*0.05
	m2.convertToSubstitution = F; 
   m2.color = "red"; 
   print(optima_value);

	initializeMutationTypeNuc("m1", 0, "f", 0.0);       // neutral


	// g1 genomic element type: uses m2 for all mutations
	initializeGenomicElementType("g1", m1, 1.0, mmJukesCantor(0.0)); 
   //initializeGenomicElementType("g2", m1, 1.0);  cannot do it 

	initializeGenomicElement(g1, 0,  length-1);

	// initialize recombination 
	initializeRecombinationRate(0.0001);

}

//// create one popualtion and then popualte the new ones 
1 early() { 

	sim.addSubpop("p999", initial_pop);  // 
	p999.genomes.readFromVCF(main_vcf, m2);  // vcf file with seelction coefficients 
	//p999.genomes.readFromVCF("qtl1_neutral.vcf", m3);
	
}

// I will always keep the effect of the mutations neutral 
// becuase I am actually using their effect as an effect size 
1:999 mutationEffect(m2) {
	return 1.; 
}

1 late(){

	// Read a list of optima from a simple text file (one line/one entry per population).
	

	for (i in 0:(replicates-1)) {
		sim.addSubpop(i, 0);   /// add just empty populations 
	}
	
	// once created the subpopulations make the migrants go to them 
	for (migrant in sim.subpopulations.individuals){
			 do {
			 //take a subpop at random 
            dest = sample(sim.subpopulations, 1);
          // make sure it is not my original subpop
        } while (dest == migrant.subpopulation);

        // Assign migrant to destination subpopulation
        dest.takeMigrants(migrant);
    }
   // now that i have taken all the individuals from pop999 i  delete it 
   p999.removeSubpopulation();

}



/////// establish a reproduction regimen where the fitness of an individual will affect the number of offspring 

2:999 reproduction() { 
// 0.97 chance of selfing, 0.03 chance of reproducing with other random individual in the same subpop 

	for (i in 0:(replicates-1)) {
	if (sim.subpopulations[i].individualCount > 0){
		inds = sim.subpopulations[i].individuals; 
 		phenotypes = inds.sumOfMutationsOfType(m2); 
		fitness = exp(-0.5 * (phenotypes - (optima_value))^2);	
	
		max_fitness = max(fitness);
		rel_fitness = fitness / max_fitness;
		offspring = rel_fitness * 10;  //max number of offsrping 
		offspring = asInteger(floor((offspring)));		
		
		
		for (j in 0:(size(sim.subpopulations[i].individuals)-1)) {
			for (k in seqLen(offspring[j])) {
				if (runif(1) < 0.97) 
					{ 
  						 sim.subpopulations[i].addSelfed(sim.subpopulations[i].individuals[j]);
  					} 
				else
  					{ 
						mate = sim.subpopulations[i].sampleIndividuals(1);
 						sim.subpopulations[i].addCrossed(sim.subpopulations[i].individuals[j], mate);
  					} 
			}
		}
	}
	}
	self.active = 0; 
}


    	
2:999 fitnessEffect() { 
	phenotype = sum(individual.genomes.sumOfMutationsOfType(m2));
  	fitness = exp(-0.5 * (phenotype - (optima_value))^2);
 	//also here I adjust for only 1 year of survival 
	return ifelse(individual.age <=1, fitness, 0.0);
}
    
    
//1:999 late() { 

	// if after the survival event the population size is too big adjust it 
//	for (i in 0:(replicates-1)){
	//	if (sim.subpopulations[i].individualCount > 500){
	//		number_to_kill = sim.subpopulations[i].individualCount - 500;		
	//		sim.killIndividuals(sim.subpopulations[i].sampleIndividuals(number_to_kill));
	//		}
			
	// check fluctuation of phenotype and fitness
//	inds = sim.subpopulations[i].individuals; 
//	phenotypes = inds.sumOfMutationsOfType(m2); 
//	fitness = exp(-0.5 * (phenotypes - (inds.subpopulation.tag))^2);
	//print(phenotypes); // if the phenotypes are all the same i could assume there is ecotype sorting 
//	catn(sim.cycle + ": Mean phen ="+ mean(phenotypes) + " optima "+ sim.subpopulations[i].tag  + " ,subpop " + i + " size:" + 			sim.subpopulations[i].individualCount) ;  	
// 	}
//	}

2:999 late() { 

	// if after the survival event the population size is too big adjust it 
	for (i in 0:(replicates-1)){
		if (sim.subpopulations[i].individualCount > 500){
			number_to_kill = sim.subpopulations[i].individualCount - 500;		
			sim.killIndividuals(sim.subpopulations[i].sampleIndividuals(number_to_kill));
			}
			}
 	}


// output 
3:999 late(){  
		if(sim.cycle==gen_to_run){
		for (i in 0:(replicates-1)){
		sim.subpopulations[i].individuals.genomes.outputVCF('vcf_slim/optima' + optima + '/subp' + i + '.vcf');
		sim.simulationFinished();  
}}}

//im not sure if this is necessary but just in case
//4 early() 
//{ 
//sim.simulationFinished();  
//}	
    

    
/*




checks
2:99999 early() { 
	print("early");
   optima = readFile(optimaFile);
	replicates = length(optima);

	// add tags of optima


	//// aca deberia ir por cada subpoblaciony  calcular esto 
 	inds = sim.subpopulations[4].individuals; 
 	
 	phenotypes = inds.sumOfMutationsOfType(m2); 
 	print(" subpop " + 4);
 	print("phenotypes");
 	print(phenotypes);
 	print(inds.subpopulation.tag);
	fitness = exp(-0.5 * (phenotypes - (inds.subpopulation.tag))^2);
 	
 	print("fitness");
 	print(fitness);
 	}




output 


    	// kill them after a year 
1:5 late() { 
	optima = readFile(optimaFile);
	replicates = length(optima);

	// add tags of optima
	for (i in 0:(replicates-1)){
	inds = sim.subpopulations[i].individuals; 
	inds.fitnessScaling = ifelse(inds.age <=1, 1.0, 0.0);
	}
 	}
 	
6:99999 early() { 
   optima = readFile(optimaFile);
	replicates = length(optima);
	for (i in 0:(replicates-1)){
    	catn("subpop " + i + " size:" + sim.subpopulations[i].individualCount) ; 
    	}
    	}
    	
    	
    	
 1:2 late() { 
// number of population based on the map file
	
   optima = readFile(optimaFile);
	replicates = length(optima);

	// add tags of optima
	for (i in 0:(replicates-1)){

	//// aca deberia ir por cada subpoblaciony  calcular esto 
 	inds = sim.subpopulations[i].individuals; 
 	
 	phenotypes = inds.sumOfMutationsOfType(m2); 
 	print(" subpop " + i);
 	print("phenotypes");
 	print(phenotypes);
 	
 	print(inds.subpopulation.tag);
	fitness = exp(-0.5 * (phenotypes - (inds.subpopulation.tag))^2);
 	
 	print("fitness");
 	print(fitness);
 	//fisher geometric model
	if (sim.cycle % 1 == 0) 
    	catn(sim.cycle + ": Mean phen ="+ mean(phenotypes) + " optima "+ sim.subpopulations[i].tag  + " ,subpop " + i + " size:" + 			sim.subpopulations[i].individualCount) ; 
    	
    	}
    	}
    	
    	
    	
//// old fitness scaling
2:99999 early() { 
// number of population based on the map file

	
   optima = readFile(optimaFile);
	replicates = length(optima);

	// add tags of optima
	for (i in 0:(replicates-1)){

	//// aca deberia ir por cada subpoblaciony  calcular esto 
 	inds = sim.subpopulations[i].individuals; 
 	
 	phenotypes = inds.sumOfMutationsOfType(m2); 
 	print(" subpop " + i);
 	print("phenotypes");
 	print(phenotypes);
 	// inds.fitnessScaling = 1.5 - (phenotypes - inds.subpopulation.tag)^2 * 0.005; 
 	//inds.fitnessScaling = exp(-0.5 * (phenotypes - inds.subpopulation.tag)^2);

 	// make sure that if you are older than 1 year then you fitness is for sure 0 (annual arabidopsis)
 	//print(inds.age);
 	//fitness = ifelse(inds.age <= 1, exp(-0.5 * (phenotypes - (inds.subpopulation.tag))^2), 0.0);
 	print(inds.subpopulation.tag);
	fitness = exp(-0.5 * (phenotypes - (inds.subpopulation.tag))^2);
 	
	inds.fitnessScaling = fitness;
 	print("fitness");
 	print(fitness);
 	//fisher geometric model
	if (sim.cycle % 1 == 0) 
    	catn(sim.cycle + ": Mean phen ="+ mean(phenotypes) + " optima "+ sim.subpopulations[i].tag  + " ,subpop " + i + " size:" + 			sim.subpopulations[i].individualCount) ; 
    	
   /// and now based on population size kill randomly inside population 
   
											}
    	
    	}
    	
    