//mybaby 

initialize() {
	initializeSLiMOptions(nucleotideBased=T);
	length = initializeAncestralNucleotides("test.fasta");
	defineConstant("L", length);
	initializeMutationTypeNuc("m1", 0, "f", 0.0);
	initializeMutationTypeNuc( "m2", 0.5, "e", 0.1);
	m2.color = "red";
	//m2.convertToSubstitution = F;
	initializeGenomicElementType("g1", m1, 1.0, mmJukesCantor(0.0));
	
	initializeGenomicElement(g1, 0, L-1);
	initializeRecombinationRate(1e-8);
}

1 late() {
	sim.addSubpop("p1", 225);
	p1.genomes.readFromVCF("chr1_grenenet_ecotypes.vcf", m1);
	p1.setSubpopulationSize(1000);   // scaling up the 10000 allows drift to not have a huge impact
	
	sim.addSubpop("p2", 14);
	p2.genomes.readFromVCF("test3.vcf", m1);
	p2.setSubpopulationSize(1000);   // scaling up the 10000 allows drift to not have a huge impact
	
	sim.addSubpop("p3", 14);
	p3.genomes.readFromVCF("test3.vcf", m1);
	p3.setSubpopulationSize(1000);   // scaling up the 10000 allows drift to not have a huge impact;\
	
	p1.setMigrationRates(p2, 0.1);   // weak migration p2 -> p1 p2.setMigrationRates(p1, 0.5);
}


/* setting up with mutation effect 
mutationEffect(m1, p1) {
	return 1.0; }  
	10000 early() { 
	sim.simulationFinished(); }
*/

// randomly taking a snp of from m2 and change its selection coefficient
// to be benefitial 
5 late() {
	mut = sample(sim.mutations, 1);
	mut.setMutationType(m2);
	mut.setSelectionCoeff(0.5);
}
100 late() {  
p1.outputSample(10); 
}


// getting the snps that fixed 

/*
1:10000 late() {
	mut = sim.mutationsOfType(m1);
	if (mut.size()) {
		f = sim.mutationFrequencies(p2, mut);
		catn(sim.cycle + ": " + sim.mutations.size() + ", f = " + f);  if (f == 1.0) {
			catn("\nFIXED in cycle " + sim.cycle);
			catn(sim.substitutions.size() + " substitutions.");
			catn(paste(sim.substitutions.nucleotide));
			sim.simulationFinished();
		}
	} else {
		catn(sim.cycle + ": " + sim.mutations.size());
	}
}
