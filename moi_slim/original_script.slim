
// Aim: a simulation of local adaptation in an island model
// assuming a Gaussian model of stabilising selection

////////////////////////////////////////////////////////////////////////////////
// Setup
initialize() {

	// Choose among environment maps
	defineConstant("optimaFile", "~/dataslim/BC_Map_environments.14x14.txt");

if (exists("slimgui")){ // start a condition for gui
// defineConstant("seed", 1);
// defineConstant("mu", 1e-7);
// defineConstant("r", 1e-8);
// defineConstant("N", 1000);
//
	// Define generations
	defineConstant("Generations", 100); // comment out for command

	// Define size of population
	defineConstant("N", 100); // comment out for command

	// Define individuals sampled
	defineConstant("n", 10); // comment out for command

	// Define selection strength
	defineConstant("s", 0.05); // comment out for command

	// Define selection strength
	defineConstant("mig", 0.1); // comment out for command

//	// Set a constant for replicates for saving multiple files
//	defineConstant("REP", 1); // For saving files

} // end definitions for guide

// end options	////////////////////////////////////////////////////////////////////////////////
	// Keep track of the tree sequence for the population
	//	initializeTreeSeq(); // not needed for purposes right now

	// mutation rate
//	initializeMutationRate(1e-1); // need high for debug
	initializeMutationRate(1e-8);

	// m2 mutation type: QTL-type
	initializeMutationType("m2", 0.5, "f", 0.0);

	// g1 genomic element type: uses m2 for all mutations
	initializeGenomicElementType("g1", m2, 1.0);

	// gene  number
	geneNumber = 1001; // This is actually 1+ the gene number

	// Initialise 12 QTL  across the genome, with a single selected base in the middle
	initializeGenomicElement(g1, 664998, 664998);
	initializeGenomicElement(g1, 1324998, 1324998);
	initializeGenomicElement(g1, 1984998, 1984998);
	initializeGenomicElement(g1, 2644998, 2644998);
	initializeGenomicElement(g1, 3304998, 3304998);
	initializeGenomicElement(g1, 3964998, 3964998);
	initializeGenomicElement(g1, 4624998, 4624998);
	initializeGenomicElement(g1, 5284998, 5284998);
	initializeGenomicElement(g1, 5944998, 5944998);
	initializeGenomicElement(g1, 6604998, 6604998);
	initializeGenomicElement(g1, 7264998, 7264998);
	initializeGenomicElement(g1, 7924998, 7924998);

	// initialize recombination and set it between genes
	r = 1e-7;
	r_inter = 0.005;
	recRates = float((geneNumber *2) -1);
	recRates[0] = r_inter;
	recBreaks = integer((geneNumber *2) -1);
	recBreaks[0] = 1;
	for (ind in seq(2,geneNumber)){
		if ( ind%asInteger(geneNumber/5) == 0 ) {
			r_inter = 0.5;
		}
		else {
			r_inter =0.005;
		}
		recRates[(ind - 1)*2 - 1] = r;
		recRates[(ind - 1)*2  ] = r_inter;
		gene_span = (ind-1)*(10000) -1;
		gene_end = (ind-1)*(10000) ;
		//		cat(gene_span + '\n');  // not necessary to print
		recBreaks[(ind-1)*2 - 1] = gene_span;
		recBreaks[(ind-1)*2 ] = gene_end;
	}
	initializeRecombinationRate(recRates, recBreaks);

}

////////////////////////////////////////////////////////////////////////////////
// Initialize simulation

//// create a subpopulation
1 { // my attempt to fix it
	optima = readFile(optimaFile);
	//	print(optima); // debug
	subpopCount = length(optima);
	sim.addSubpop("p999", 196*N);
}

// Initialize quantitative trait evolution form through fitness
// the QTLs themselves are selectively neutral; their selective effect is generated by their contribution to the phenotype and that is handled below
fitness(m2) {
	return 1.0;
}
////////////////////////////////////////////////////////////////////////////////
// RUN SIMULATIONS
// 100 late(){
9 late(){

	// Read a list of optima from a simple text file (one line/one entry per population).
	optima = readFile(optimaFile);

	// number of population based on the map file
	subpopCount = length(optima);

	// add tags of optima
	for (i in 0:(subpopCount-1)){
		// make subpopulation splits, all with N size
		sim.addSubpopSplit(i, N, p999);
		// Add a tag to the subpopulation that will be the optima
		sim.subpopulations[i].tag = asInteger(optima[i]);
		//		// print for debug
		//		print(		sim.subpopulations[i].tag);
	}

	// Reduce the initial subpopulation to 0 individuals
	p999.setSubpopulationSize(0); // DONT UNDERSTAND THIS

	// Establish migration across all 2D demes throught the squared grid
//		mig = 7.5 / ( 2*N ); // original
	sLen = asInteger(sqrt(subpopCount));
	// start counter of population
	subpop=0;
	mypops=c();
	myrows=c();
	mycols=c();
	// iterate through rows and columns adding migration as in a 2D stepping stone model
	for (row in 1:sLen-1) {
		for(col in 1:sLen-1){
		// add indeces
			mypops=c(mypops,subpop);
			myrows=c(myrows,row);
			mycols=c(mycols,col);
		//Left migration
		if (col != 0){
			sim.subpopulations[subpop].setMigrationRates(subpop-1, mig);
		}
		//Right migration
		if (col < sLen-1){
			sim.subpopulations[subpop].setMigrationRates(subpop+1 , mig);
		}
		//Up migration
		if (row > 0){
			sim.subpopulations[subpop].setMigrationRates(subpop - sLen  , mig);
		}
		//Down migration
		if (row < sLen-1){
			sim.subpopulations[subpop].setMigrationRates(subpop+sLen, mig);
		}
		subpop=subpop+1 ;
		}
	}

}


//// Run evolution with directional selection
// Until 20000 generations of adapting to a dumb optimum
11:20 fitness(m2) {
	return 1. + s*0;
}

// Then, impose a model of stabilising selection, where all populations are adapting to the same optimum of 0.0, and fitness deviates from 1 proportional to s and the tag from the map file that is around 0 and ranges =-10, so the optimum changes in space
21:9999 fitness(m2) {
	return 1. + s* individual.subpopulation.tag;
	//				return 1. + s*genome1.individual.subpopulation.tag;
}

//// Output stuff
10000 late(){  // making this just 31 generations to test
	sLen=14;
	subpop=0;
	mypops=c();
	myrows=c();
	mycols=c();
	// iterate through rows and columns adding migration as in a 2D stepping stone model
	for (row in 1:sLen-1) {
		for(col in 1:sLen-1){
		// add indeces
			mypops=c(mypops,subpop);
			myrows=c(myrows,row);
			mycols=c(mycols,col);
			subpop=subpop+1 ;
		}
	}
	cat("\narea\tsegsites\n");
	for (grid in 1:sLen-1) {
		// grow a grid starting in a corner and sample and output area and S
		subsetpops= mypops[which(myrows<= grid & mycols <=grid)];
		mysample=sim.subpopulations[subsetpops].sampleIndividuals(n).genomes;
		// get the unique mutations in the sample, sorted by position
		m = sortBy(unique(mysample.mutations), "position");
		// export with area already squared
		cat(size(subsetpops)^2+"\t"+size(m)+"\n");
	}
}
