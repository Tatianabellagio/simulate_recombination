// modified by Tati 
// now i wll try o non writ fisher model 
// now reading from vcf files with selection coefficient drawn from 2 gaussian distributions that add up to a PRS
// One QTL for now 
// there is an otima for each subpopulation particular to each subpopulation based on the optima file 

// Aim: a simulation of local adaptation in an island model
// assuming a Gaussian model of stabilising selection

////////////////////////////////////////////////////////////////////////////////
// Setup
initialize() {

	// the optima file is a vector indicating the optima for each of the environments 
	defineConstant("optimaFile", "BC_Map_environments.4x4.txt");

if (exists("slimgui")){ 
    // start a condition for gui, aka only is you are in the slim interface setup these constants 

	// Define generations
	//defineConstant("Generations", 100); 

	// Define size of population
	//defineConstant("N", 1000); 

	// Define individuals sampled
	//defineConstant("n", 10); 

	// Define selection strength // selection will be based on qtl effect size
	// defineConstant("s", 0.05); 

	// Define migration among subpopulations // no migracion for me
	//defineConstant("mig", 0.1); 

//	// Set a constant for replicates for saving multiple files
//	defineConstant("REP", 1); // For saving files

} 
// end options	////////////////////////////////////////////////////////////////////////////////
	// Keep track of the tree sequence for the population
	//	initializeTreeSeq(); // not needed for purposes right now

	// mutation rate
    //	initializeMutationRate(1e-1); // need high for debug
    
   // now im gonna simulate the mutations coming from standing variation. 
   initializeSLiMModelType("nonWF");
   initializeSLiMOptions(nucleotideBased=T);
	length = initializeAncestralNucleotides("test.fasta");   
	defineConstant("L", length);
	initializeMutationTypeNuc("m2", 0, "n", 0, 0.001);   // qtl1 0.2 contributing 492 SNPS
	m2.convertToSubstitution = F; 
   m2.color = "red"; 
   
	initializeMutationTypeNuc("m3", 0, "n", 0, 0.0001);   // qtl1 0.8 noncontributing  4920 - 492
	m3.convertToSubstitution = F; 
   m3.color = "blue"; 
	
	//initializeMutationTypeNuc("m4", 0, "n", 0, 0);   // qtl2 0.2 contributing 
	//initializeMutationTypeNuc("m5", 0, "n", 0, 0.00);   // qtl2 0.8 noncontributing 

	initializeMutationTypeNuc("m1", 0.5, "f", 0.0);       // neutral

   
   
	//initializeMutationRate(1e-8);

	// m2 mutation type: QTL-type 
    // create a mutation type 2 with 0.5 dominance and selection coeff of mean 0 and sd 0.1 just to use them as effect sizes
	//initializeMutationType("m2", 0.5, "g", 0.1, 2);
   //m2.convertToSubstitution = F; 
   m2.color = "red"; 
	// g1 genomic element type: uses m2 for all mutations
	initializeGenomicElementType("g1", m1, 1.0, mmJukesCantor(0.0)); 
   //initializeGenomicElementType("g2", m1, 1.0);  cannot do it 

	// gene  number
	//geneNumber = 1001; 
    // This is actually 1+ the gene number

	// Initialise 1 QTL  across the genome, with a single selected base in the middle WHY??
	initializeGenomicElement(g1, 0,  L-1);

	// initialize recombination and set it between genes

	initializeRecombinationRate(0);

}


reproduction() { 
// 0.97 chance of selfing, 0.03 chance of reproducing with other random individual in the same subpop 

	if (runif(1) < 0.97) 
  { 
	// reproduce through automixis   
	offspring = subpop.addSelfed(individual); 
  } 
	else
  { 
  // choose a random mate 
   offspring = subpop.addCrossed(individual, subpop.sampleIndividuals(1));     
  } 
	
}






//reproduction() {
	//subpop.addSelfed(individual, subpop.sampleIndividuals(1)); //addself
//}

////////////////////////////////////////////////////////////////////////////////
// Initialize simulation

//// create 1 big subpopulation with the number fo individuals needed to fill the number of different optima times the 
// number of individuals in each, remember N is pop size 
1 early() { 
	optima = readFile(optimaFile);
	print(optima); 
	subpopCount = asInteger(length(optima));
	sim.addSubpop("p999", 225);
	//p999.setSelfingRate(0.97); 	//WF
	
	p999.genomes.readFromVCF("qtl1_contrib.vcf", m2);
	p999.genomes.readFromVCF("qtl1_neutral.vcf", m3);
	
	//p999.genomes.readFromVCF("qtl2_contrib.vcf", m4);
	//p999.genomes.readFromVCF("qtl2_neutral.vcf", m5);
	
	p999.genomes.readFromVCF("inv1.vcf", m1);
	p999.genomes.readFromVCF("inv2.vcf", m1);
	//p999.setSubpopulationSize(16*N); 
	
	
}
	

// Initialize quantitative trait evolution form through fitness
// the QTLs themselves are selectively neutral; 
// their selective effect is generated by their contribution to the phenotype and that is handled below
//mutationEffect(m2) {
//	return 1.0;
//}
////////////////////////////////////////////////////////////////////////////////
// RUN SIMULATIONS
// 100 late(){





2 late(){

	// Read a list of optima from a simple text file (one line/one entry per population).
	optima = readFile(optimaFile);

	// number of population based on the map file
	subpopCount = length(optima);
	

	for (i in 0:(subpopCount-1)){
		sim.addSubpop(i, 0);   /// add just empty populations 
		sim.subpopulations[i].tag = asInteger(optima[i]);
	

	// add tags of optima
	//for (i in 0:(subpopCount-1)){
		// from the big subpopulation p999 make subpopulation splits, all with N size
		//sim.addSubpopSplit(i, N, p999);
		//sim.subpopulations[i].setSelfingRate(0.97); //WF
		// Add a tag to the subpopulation that will be the optima
		//sim.subpopulations[i].tag = asInteger(optima[i]);
		//		// print for debug
		//		print(		sim.subpopulations[i].tag);
	}

	// Reduce the initial subpopulation to 0 individuals

	//p999.setSubpopulationSize(0); 
    // this is to avoid for individuals to migrate back to the p999
}
// deleted all the code setting migration rates since in slim, by default the migration rate is set to 0

//// Run evolution with directional selection
// Until 20000 generations of adapting to a dumb optimum

// i will take all the individuals in my population and use them
// as migrants


3 late(){
	for (migrant in sim.subpopulations.individuals){
			 do {
			 //take a subpop at random 
            dest = sample(sim.subpopulations, 1);
          // make sure it is not my original subpop
        } while (dest == migrant.subpopulation);

        // Assign migrant to destination subpopulation
        dest.takeMigrants(migrant);
    }

}


//p999.setSubpopulationSize(0); 

1:3 mutationEffect(m2) {
	return 1.; //+ s*0;
}

1:3 mutationEffect(m3) {
	return 1.; //+ s*0;
}

1:3 mutationEffect(m4) {
	return 1.; //+ s*0;
}

1:3 mutationEffect(m5) {
	return 1.; //+ s*0;
}




4:99999 late() { 
// number of population based on the map file
   optima = readFile(optimaFile);
	subpopCount = length(optima);

	// add tags of optima
	for (i in 0:(subpopCount-1)){

//// aca deberia ir por cada subpoblaciony  calcular esto 
 	inds = sim.subpopulations[i].individuals; 
 	//print(inds);
 	
   //numberofmut = inds.countOfMutationsOfType(m2); 
 	//print(numberofmut);
 	
 	phenotypes = inds.sumOfMutationsOfType(m2) + inds.sumOfMutationsOfType(m3); 
 	//print(phenotypes);
 	//print(inds.sumOfMutationsOfType(m2));
 	//print(inds.fitnessScaling);
 	//print(inds.fitnessScaling); // this will be always a vector of 1 fitnessScaling is reset to 1.0 every tick, so that any scaling factor set lasts for only a  single tick.
 	
 	// inds.fitnessScaling = 1.5 - (phenotypes - inds.subpopulation.tag)^2 * 0.005; 
 	//inds.fitnessScaling = exp(-0.5 * (phenotypes - inds.subpopulation.tag)^2);
 	
 	// make sure that if you are older than 1 year then you fitness is for sure 0 (annual arabidopsis)
 	inds.fitnessScaling = ifelse(inds.age <= 1, exp(-0.5 * (phenotypes - inds.subpopulation.tag)^2), 0.0);

 	//print(inds.fitnessScaling); fisher geometric model
	if (sim.cycle % 1 == 0) 
    	catn(sim.cycle + ": Mean phen ="+ mean(phenotypes) + " optima "+ sim.subpopulations[i].tag  + " ,subpop " + i) ; 
    	}
    	}
    
    
    
// Then, impose a model of stabilising selection, where all populations are adapting to the same optimum of 
// 0.0, and fitness deviates from 1 proportional to s and the tag from the map file that is around 0 and ranges =-10, so the optimum changes in space
//21:9999 mutationEffect(m2) {
   // print(individual.subpopulation.tag);
//	return 1. + s* individual.subpopulation.tag;
	//				return 1. + s*genome1.individual.subpopulation.tag;
//}


7 late(){  
		optima = readFile(optimaFile);
		subpopCount = length(optima);
		for (i in 0:(subpopCount-1)){
			sim.subpopulations[i].individuals.genomes.outputVCF('vcf_clim/subp' + i + '.vcf');
}}

/*
//// Output stuff
10 late(){  // making this just 31 generations to test
	optima = readFile(optimaFile);
	subpopCount = length(optima);

	// add tags of optima
	for (i in 0:(subpopCount-1)){

//// aca deberia ir por cada subpoblaciony  calcular esto

	output_path = "outputs/result" + string(i) + ".vcf";
 
 	genomes = sim.subpopulations[i].individuals.genomes; 
 	genomes.outputVCF(output_path, i);
}
}

	