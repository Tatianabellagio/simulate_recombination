// modified by Tati 


// i will work with only one qtl 

// trial 1: we will better get the different effect sizes for the qtls from a lognormal dsitribution 
// will use the technique of the selection coefficient to get that distribution of effect sizes and then impose an optima 
// particular to each subpopulation based on the optima file 

// Aim: a simulation of local adaptation in an island model
// assuming a Gaussian model of stabilising selection

////////////////////////////////////////////////////////////////////////////////
// Setup
initialize() {

	// the optima file is a vector indicating the optima for each of the environments 
	defineConstant("optimaFile", "BC_Map_environments.4x4.txt");

if (exists("slimgui")){ 
    // start a condition for gui, aka only is you are in the slim interface setup these constants 

	// Define generations
	defineConstant("Generations", 100); 

	// Define size of population
	defineConstant("N", 100); 

	// Define individuals sampled
	defineConstant("n", 10); 

	// Define selection strength // selection will be based on qtl effect size
	// defineConstant("s", 0.05); 

	// Define migration among subpopulations // no migracion for me
	//defineConstant("mig", 0.1); 

//	// Set a constant for replicates for saving multiple files
//	defineConstant("REP", 1); // For saving files

} 
// end options	////////////////////////////////////////////////////////////////////////////////
	// Keep track of the tree sequence for the population
	//	initializeTreeSeq(); // not needed for purposes right now

	// mutation rate
    //	initializeMutationRate(1e-1); // need high for debug
    

	initializeMutationRate(1e-8);

	// m2 mutation type: QTL-type 
    // create a mutation type 2 with 0.5 dominance and selection coeff of mean 0 and sd 0.1 just to use them as effect sizes
	initializeMutationType("m2", 0.5, "g", 0.1, 2);
   m2.convertToSubstitution = F; 
   m2.color = "red"; 
	// g1 genomic element type: uses m2 for all mutations
	initializeGenomicElementType("g1", m2, 1.0); 

	// gene  number
	geneNumber = 1001; 
    // This is actually 1+ the gene number

	// Initialise 1 QTL  across the genome, with a single selected base in the middle WHY??
	initializeGenomicElement(g1, 0, 1000000);

	// initialize recombination and set it between genes

	initializeRecombinationRate(1e-8);

}

////////////////////////////////////////////////////////////////////////////////
// Initialize simulation

//// create 1 big subpopulation with the number fo individuals needed to fill the number of different optima times the 
// number of individuals in each, remember N is pop size 
1 early() { 
	optima = readFile(optimaFile);
	print(optima); 
	subpopCount = asInteger(length(optima));
	sim.addSubpop("p999", 16*N);
}

// Initialize quantitative trait evolution form through fitness
// the QTLs themselves are selectively neutral; 
// their selective effect is generated by their contribution to the phenotype and that is handled below
//mutationEffect(m2) {
//	return 1.0;
//}
////////////////////////////////////////////////////////////////////////////////
// RUN SIMULATIONS
// 100 late(){
9 late(){

	// Read a list of optima from a simple text file (one line/one entry per population).
	optima = readFile(optimaFile);

	// number of population based on the map file
	subpopCount = length(optima);

	// add tags of optima
	for (i in 0:(subpopCount-1)){
		// from the big subpopulation p999 make subpopulation splits, all with N size
		sim.addSubpopSplit(i, N, p999);
		// Add a tag to the subpopulation that will be the optima
		sim.subpopulations[i].tag = asInteger(optima[i]);
		//		// print for debug
		//		print(		sim.subpopulations[i].tag);
	}

	// Reduce the initial subpopulation to 0 individuals

	p999.setSubpopulationSize(0); 
    // this is to avoid for individuals to migrate back to the p999
}
// deleted all the code setting migration rates since in slim, by default the migration rate is set to 0

//// Run evolution with directional selection
// Until 20000 generations of adapting to a dumb optimum


11:20 mutationEffect(m2) {
	return 1.; //+ s*0;
}



21:99999 late() { 
// number of population based on the map file
   optima = readFile(optimaFile);
	subpopCount = length(optima);

	// add tags of optima
	for (i in 0:(subpopCount-1)){

//// aca deberia ir por cada subpoblaciony  calcular esto 
 	inds = sim.subpopulations[i].individuals; 
 	//print(inds);
 	
   numberofmut = inds.countOfMutationsOfType(m2); 
 	//print(numberofmut);
 	
 	phenotypes = inds.sumOfMutationsOfType(m2); 
 	//print(phenotypes);
 	//print(inds.sumOfMutationsOfType(m2));
 	//print(inds.fitnessScaling);
 	//print(inds.fitnessScaling); // this will be always a vector of 1 fitnessScaling is reset to 1.0 every tick, so that any scaling factor set lasts for only a  single tick.
 	
 	// inds.fitnessScaling = 1.5 - (phenotypes - inds.subpopulation.tag)^2 * 0.005; 
 	inds.fitnessScaling = exp(-0.5 * (phenotypes - inds.subpopulation.tag)^2);
 	//print(inds.fitnessScaling);
 	//print(inds.fitnessScaling);
	if (sim.cycle % 100 == 0) 
    	catn(sim.cycle + ": Mean phen ="+ mean(phenotypes) + " optima "+ sim.subpopulations[i].tag  + " ,subpop " + i) ; 
    	}
    	}
    
    
    
// Then, impose a model of stabilising selection, where all populations are adapting to the same optimum of 
// 0.0, and fitness deviates from 1 proportional to s and the tag from the map file that is around 0 and ranges =-10, so the optimum changes in space
//21:9999 mutationEffect(m2) {
   // print(individual.subpopulation.tag);
//	return 1. + s* individual.subpopulation.tag;
	//				return 1. + s*genome1.individual.subpopulation.tag;
//}


//// Output stuff
10000 late(){  // making this just 31 generations to test
    // 14 because that is the value of columns/row based on the optima file 
	sLen=4;
	subpop=0;
	mypops=c();
	myrows=c();
	mycols=c();
	// iterate through rows and columns adding migration as in a 2D stepping stone model
	for (row in 1:sLen-1) {
		for(col in 1:sLen-1){
		// add indeces
			mypops=c(mypops,subpop);
			myrows=c(myrows,row);
			mycols=c(mycols,col);
			subpop=subpop+1 ;
		}
	}
	cat("\narea\tsegsites\n");
	for (grid in 1:sLen-1) {
		// grow a grid starting in a corner and sample and output area and S
		subsetpops= mypops[which(myrows<= grid & mycols <=grid)];
		mysample=sim.subpopulations[subsetpops].sampleIndividuals(n).genomes;
		// get the unique mutations in the sample, sorted by position
		m = sortBy(unique(mysample.mutations), "position");
		// export with area already squared
		cat(size(subsetpops)^2+"\t"+size(m)+"\n");
	}
}
