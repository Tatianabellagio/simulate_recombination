// modified by Tati 
// now reading from vcf files with selection coefficient drawn from a gaussian distribution 

// i will work with only one qtl 

// trial 1: we will better get the different effect sizes for the qtls from a lognormal dsitribution 
// will use the technique of the selection coefficient to get that distribution of effect sizes and then impose an optima 
// particular to each subpopulation based on the optima file 

// Aim: a simulation of local adaptation in an island model
// assuming a Gaussian model of stabilising selection

////////////////////////////////////////////////////////////////////////////////
// Setup
initialize() {

	// the optima file is a vector indicating the optima for each of the environments 
	defineConstant("optimaFile", "BC_Map_environments.4x4.txt");

if (exists("slimgui")){ 
    // start a condition for gui, aka only is you are in the slim interface setup these constants 

	// Define generations
	//defineConstant("Generations", 100); 

	// Define size of population
	defineConstant("N", 1000); 

	// Define individuals sampled
	//defineConstant("n", 10); 

	// Define selection strength // selection will be based on qtl effect size
	// defineConstant("s", 0.05); 

	// Define migration among subpopulations // no migracion for me
	//defineConstant("mig", 0.1); 

//	// Set a constant for replicates for saving multiple files
//	defineConstant("REP", 1); // For saving files

} 
// end options	////////////////////////////////////////////////////////////////////////////////
	// Keep track of the tree sequence for the population
	//	initializeTreeSeq(); // not needed for purposes right now

	// mutation rate
    //	initializeMutationRate(1e-1); // need high for debug
    
   // now im gonna simulate the mutations coming from standing variation. 
   initializeSLiMOptions(nucleotideBased=T);
	length = initializeAncestralNucleotides("test.fasta");   
	defineConstant("L", length);
	initializeMutationTypeNuc("m2", 0, "n", 0, 0.3);   // qtl1 0.2 contributing 492 SNPS
	m2.convertToSubstitution = F; 
   m2.color = "red"; 
   
	initializeMutationTypeNuc("m3", 0, "n", 0, 0.001);   // qtl1 0.8 noncontributing  4920 - 492
	m3.convertToSubstitution = F; 
   m3.color = "blue"; 
	
	//initializeMutationTypeNuc("m4", 0, "n", 0, 0);   // qtl2 0.2 contributing 
	//initializeMutationTypeNuc("m5", 0, "n", 0, 0.00);   // qtl2 0.8 noncontributing 

	initializeMutationTypeNuc("m1", 0.5, "f", 0.0);       // neutral

   
   
	//initializeMutationRate(1e-8);

	// m2 mutation type: QTL-type 
    // create a mutation type 2 with 0.5 dominance and selection coeff of mean 0 and sd 0.1 just to use them as effect sizes
	//initializeMutationType("m2", 0.5, "g", 0.1, 2);
   m2.convertToSubstitution = F; 
   m2.color = "red"; 
	// g1 genomic element type: uses m2 for all mutations
	initializeGenomicElementType("g1", m1, 1.0, mmJukesCantor(0.0)); 
   //initializeGenomicElementType("g2", m1, 1.0);  cannot do it 

	// gene  number
	//geneNumber = 1001; 
    // This is actually 1+ the gene number

	// Initialise 1 QTL  across the genome, with a single selected base in the middle WHY??
	initializeGenomicElement(g1, 0,  L-1);

	// initialize recombination and set it between genes

	initializeRecombinationRate(0);

}

////////////////////////////////////////////////////////////////////////////////
// Initialize simulation

//// create 1 big subpopulation with the number fo individuals needed to fill the number of different optima times the 
// number of individuals in each, remember N is pop size 
1 early() { 
	optima = readFile(optimaFile);
	print(optima); 
	subpopCount = asInteger(length(optima));
	sim.addSubpop("p999", 225);
	p999.setSelfingRate(0.97); 	
	
	p999.genomes.readFromVCF("qtl1_contrib.vcf", m2);
	p999.genomes.readFromVCF("qtl1_neutral.vcf", m3);
	
	//p999.genomes.readFromVCF("qtl2_contrib.vcf", m4);
	//p999.genomes.readFromVCF("qtl2_neutral.vcf", m5);
	
	p999.genomes.readFromVCF("inv1.vcf", m1);
	p999.genomes.readFromVCF("inv2.vcf", m1);
	p999.setSubpopulationSize(16*N); 
	
	
}
	

// Initialize quantitative trait evolution form through fitness
// the QTLs themselves are selectively neutral; 
// their selective effect is generated by their contribution to the phenotype and that is handled below
//mutationEffect(m2) {
//	return 1.0;
//}
////////////////////////////////////////////////////////////////////////////////
// RUN SIMULATIONS
// 100 late(){
5 late(){

	// Read a list of optima from a simple text file (one line/one entry per population).
	optima = readFile(optimaFile);

	// number of population based on the map file
	subpopCount = length(optima);

	// add tags of optima
	for (i in 0:(subpopCount-1)){
		// from the big subpopulation p999 make subpopulation splits, all with N size
		sim.addSubpopSplit(i, N, p999);
		sim.subpopulations[i].setSelfingRate(0.97);
		// Add a tag to the subpopulation that will be the optima
		sim.subpopulations[i].tag = asInteger(optima[i]);
		//		// print for debug
		//		print(		sim.subpopulations[i].tag);
	}

	// Reduce the initial subpopulation to 0 individuals

	p999.setSubpopulationSize(0); 
    // this is to avoid for individuals to migrate back to the p999
}
// deleted all the code setting migration rates since in slim, by default the migration rate is set to 0

//// Run evolution with directional selection
// Until 20000 generations of adapting to a dumb optimum


1:6 mutationEffect(m2) {
	return 1.; //+ s*0;
}

1:6 mutationEffect(m3) {
	return 1.; //+ s*0;
}

1:6 mutationEffect(m4) {
	return 1.; //+ s*0;
}

1:6 mutationEffect(m5) {
	return 1.; //+ s*0;
}




6:99999 late() { 
// number of population based on the map file
   optima = readFile(optimaFile);
	subpopCount = length(optima);

	// add tags of optima
	for (i in 0:(subpopCount-1)){

//// aca deberia ir por cada subpoblaciony  calcular esto 
 	inds = sim.subpopulations[i].individuals; 
 	//print(inds);
 	
   //numberofmut = inds.countOfMutationsOfType(m2); 
 	//print(numberofmut);
 	
 	phenotypes = inds.sumOfMutationsOfType(m2) + inds.sumOfMutationsOfType(m3); 
 	//print(phenotypes);
 	//print(inds.sumOfMutationsOfType(m2));
 	//print(inds.fitnessScaling);
 	//print(inds.fitnessScaling); // this will be always a vector of 1 fitnessScaling is reset to 1.0 every tick, so that any scaling factor set lasts for only a  single tick.
 	
 	// inds.fitnessScaling = 1.5 - (phenotypes - inds.subpopulation.tag)^2 * 0.005; 
 	inds.fitnessScaling = exp(-0.5 * (phenotypes - inds.subpopulation.tag)^2);

 	//print(inds.fitnessScaling); fisher geometric model
	if (sim.cycle % 1 == 0) 
    	catn(sim.cycle + ": Mean phen ="+ mean(phenotypes) + " optima "+ sim.subpopulations[i].tag  + " ,subpop " + i) ; 
    	}
    	}
    
    
    
// Then, impose a model of stabilising selection, where all populations are adapting to the same optimum of 
// 0.0, and fitness deviates from 1 proportional to s and the tag from the map file that is around 0 and ranges =-10, so the optimum changes in space
//21:9999 mutationEffect(m2) {
   // print(individual.subpopulation.tag);
//	return 1. + s* individual.subpopulation.tag;
	//				return 1. + s*genome1.individual.subpopulation.tag;
//}

7 late(){  
	sim.subpopulations[0].individuals.genomes.outputVCF('outputs/subp0.vcf');
	sim.subpopulations[1].individuals.genomes.outputVCF('outputs/subp1.vcf');
	sim.subpopulations[2].individuals.genomes.outputVCF('outputs/subp2.vcf');
	sim.subpopulations[3].individuals.genomes.outputVCF('outputs/subp3.vcf');
	sim.subpopulations[4].individuals.genomes.outputVCF('outputs/subp4.vcf');
	sim.subpopulations[5].individuals.genomes.outputVCF('outputs/subp5.vcf');
	sim.subpopulations[6].individuals.genomes.outputVCF('outputs/subp6.vcf');
	sim.subpopulations[7].individuals.genomes.outputVCF('outputs/subp7.vcf');
	sim.subpopulations[8].individuals.genomes.outputVCF('outputs/subp8.vcf');
	sim.subpopulations[9].individuals.genomes.outputVCF('outputs/subp9.vcf');
	sim.subpopulations[10].individuals.genomes.outputVCF('outputs/subp10.vcf');
	sim.subpopulations[11].individuals.genomes.outputVCF('outputs/subp11.vcf');
	sim.subpopulations[12].individuals.genomes.outputVCF('outputs/subp12.vcf');	
	sim.subpopulations[13].individuals.genomes.outputVCF('outputs/subp13.vcf');	
	sim.subpopulations[14].individuals.genomes.outputVCF('outputs/subp14.vcf');	
	sim.subpopulations[15].individuals.genomes.outputVCF('outputs/subp15.vcf');	

	
}

/*
//// Output stuff
10 late(){  // making this just 31 generations to test
	optima = readFile(optimaFile);
	subpopCount = length(optima);

	// add tags of optima
	for (i in 0:(subpopCount-1)){

//// aca deberia ir por cada subpoblaciony  calcular esto

	output_path = "outputs/result" + string(i) + ".vcf";
 
 	genomes = sim.subpopulations[i].individuals.genomes; 
 	genomes.outputVCF(output_path, i);
}
}
