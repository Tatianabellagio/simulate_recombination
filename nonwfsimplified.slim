// modified by Tati 
// now i wll try o non writ fisher model 
// now reading from vcf files with selection coefficient drawn from 2 gaussian distributions that add up to a PRS
// One QTL for now 
// there is an otima for each subpopulation particular to each subpopulation based on the optima file 

// Aim: a simulation of local adaptation in an island model
// assuming a Gaussian model of stabilising selection

////////////////////////////////////////////////////////////////////////////////
// Setup
initialize() {

	// the optima file is a vector indicating the optima for each of the environments 
	defineConstant("optimaFile", "BC_Map_environments.4x4.txt");

if (exists("slimgui")){ 


} 
// end options	////////////////////////////////////////////////////////////////////////////////
	// Keep track of the tree sequence for the population
	//	initializeTreeSeq(); // not needed for purposes right now


   // now im gonna simulate the mutations coming from standing variation. 
   initializeSLiMModelType("nonWF");
   initializeSLiMOptions(nucleotideBased=T);
	length = initializeAncestralNucleotides("test.fasta");   
	defineConstant("L", length);
	initializeMutationTypeNuc("m2", 0, "n", 0, 0.1);   // qtl1 0.2 contributing 492 SNPS
	m2.convertToSubstitution = F; 
   m2.color = "red"; 
   
	initializeMutationTypeNuc("m3", 0, "n", 0, 0.0001);   // qtl1 0.8 noncontributing  4920 - 492 = 4428
	m3.convertToSubstitution = F; 
   m3.color = "blue"; 
	
	//initializeMutationTypeNuc("m4", 0, "n", 0, 0);   // qtl2 0.2 contributing 
	//initializeMutationTypeNuc("m5", 0, "n", 0, 0.00);   // qtl2 0.8 noncontributing 

	initializeMutationTypeNuc("m1", 0.5, "f", 0.0);       // neutral

   
  
   m2.color = "red"; 
	// g1 genomic element type: uses m2 for all mutations
	initializeGenomicElementType("g1", m1, 1.0, mmJukesCantor(0.0)); 
   //initializeGenomicElementType("g2", m1, 1.0);  cannot do it 

	initializeGenomicElement(g1, 0,  L-1);

	// initialize recombination 
	initializeRecombinationRate(0.0001);

}

//// create one popualtion and then popualte the new ones 
1 early() { 
	optima = readFile(optimaFile);
	subpopCount = asInteger(length(optima));
	sim.addSubpop("p999", 900);  //initial was 225
	//p999.setSelfingRate(0.97); 	//WF
	
	p999.genomes.readFromVCF("qtl1_contrib.vcf", m2);
	p999.genomes.readFromVCF("qtl1_neutral.vcf", m3);
	
	//p999.genomes.readFromVCF("qtl2_contrib.vcf", m4);
	//p999.genomes.readFromVCF("qtl2_neutral.vcf", m5);
	
	//p999.genomes.readFromVCF("inv1.vcf", m1);
	//p999.genomes.readFromVCF("inv2.vcf", m1);
	//p999.setSubpopulationSize(16*N); 
	
	
}
	
// there will be two types of reporduction events, the first one will be just cloning to make the population bigger

1:4 reproduction() {
	offspring = subpop.addCloned(individual); 

}



/////// ok so now i want to establish a reproduction regimen where the fitness of an individual will affect the number of offspring 




7:999 reproduction() { 
// 0.97 chance of selfing, 0.03 chance of reproducing with other random individual in the same subpop 
	optima = readFile(optimaFile);
	subpopCount = length(optima);
	

	for (i in 0:(subpopCount-1)) {
		fitness = sim.subpopulations[i].cachedFitness(NULL);
		print(fitness);
		offspring = asInteger(floor(fitness*10));
		print(size(fitness));
		print(size(offspring));
		print(offspring);
		
		for (j in 0:(size(sim.subpopulations[i].individuals)-1)) {
			for (k in seqLen(offspring[j])) {
			print(k);
				if (runif(1) < 0.97) 
					{ 
						// choose a male mate and produce a son or daughter    mate = subpop.sampleIndividuals(1, tag=0); 
  						 sim.subpopulations[i].addSelfed(sim.subpopulations[i].individuals[j]);
  					} 
				else
  					{ 
						// reproduce through automixis to produce a daughter    offspring = subpop.addSelfed(individual); 
						mate = sim.subpopulations[i].sampleIndividuals(1);
 						sim.subpopulations[i].addCrossed(sim.subpopulations[i].individuals[j], mate);
  					} 
			}
		}
	}
	self.active = 0; 
}


/////////
	

5 late(){

	// Read a list of optima from a simple text file (one line/one entry per population).
	optima = readFile(optimaFile);

	// number of population based on the map file
	subpopCount = length(optima);
	

	for (i in 0:(subpopCount-1)) {
		sim.addSubpop(i, 0);   /// add just empty populations 
		sim.subpopulations[i].tag = asInteger(optima[i]);
	}
	
	// once created the subpopulations make the migrants go to them 
	for (migrant in sim.subpopulations.individuals){
			 do {
			 //take a subpop at random 
            dest = sample(sim.subpopulations, 1);
          // make sure it is not my original subpop
        } while (dest == migrant.subpopulation);

        // Assign migrant to destination subpopulation
        dest.takeMigrants(migrant);
    }
   // now that i have taken all the individuals from pop999 i  delete it 
   p999.removeSubpopulation();

}



1:5 mutationEffect(m2) {
	return 1.; //+ s*0;
}

1:5 mutationEffect(m3) {
	return 1.; //+ s*0;
}

1:5 mutationEffect(m4) {
	return 1.; //+ s*0;
}

1:5 mutationEffect(m5) {
	return 1.; //+ s*0;
}


6:99999 early() { 
   optima = readFile(optimaFile);
	subpopCount = length(optima);
	for (i in 0:(subpopCount-1)){
    	catn("subpop " + i + " size:" + sim.subpopulations[i].individualCount) ; 
    	}
    	}
    	
    	



6:99999 late() { 
// number of population based on the map file
	
   optima = readFile(optimaFile);
	subpopCount = length(optima);

	// add tags of optima
	for (i in 0:(subpopCount-1)){

	//// aca deberia ir por cada subpoblaciony  calcular esto 
 	inds = sim.subpopulations[i].individuals; 
 	
 	phenotypes = inds.sumOfMutationsOfType(m2) + inds.sumOfMutationsOfType(m3); 
 	
 	
 	// inds.fitnessScaling = 1.5 - (phenotypes - inds.subpopulation.tag)^2 * 0.005; 
 	//inds.fitnessScaling = exp(-0.5 * (phenotypes - inds.subpopulation.tag)^2);
 	
 	// make sure that if you are older than 1 year then you fitness is for sure 0 (annual arabidopsis)
 	//print(inds.age);
 	inds.fitnessScaling = ifelse(inds.age <= 1, exp(-0.5 * (phenotypes - inds.subpopulation.tag)^2), 0.0);

 	//print(inds.fitnessScaling); fisher geometric model
	if (sim.cycle % 1 == 0) 
    	catn(sim.cycle + ": Mean phen ="+ mean(phenotypes) + " optima "+ sim.subpopulations[i].tag  + " ,subpop " + i + " size:" + sim.subpopulations[i].individualCount) ; 
    	}
    	}
    
    
    
/* output 
7 late(){  
		optima = readFile(optimaFile);
		subpopCount = length(optima);
		for (i in 0:(subpopCount-1)){
			sim.subpopulations[i].individuals.genomes.outputVCF('vcf_clim/subp' + i + '.vcf');
}}

    	// kill them after a year 
1:5 late() { 
	optima = readFile(optimaFile);
	subpopCount = length(optima);

	// add tags of optima
	for (i in 0:(subpopCount-1)){
	inds = sim.subpopulations[i].individuals; 
	inds.fitnessScaling = ifelse(inds.age <=1, 1.0, 0.0);
	}
 	}